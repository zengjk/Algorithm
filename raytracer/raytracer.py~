import numpy as np
import matplotlib.pyplot as plt
'''
This program is written in python 2.7.5, and maybe not working in python3. Make sure numpy and matplotlib are installed correctly.

To generate a ray, run
    ry = ray(pos,dir)
,which will generate a ray at 'pos'(a 3D vector) with its direction 'dir'(a 3D vector)

To create an optical element, use
    ele = spherical_refraction(z0,curv,n1,n2,ar)
, here ar is by default equal to 50, which is big enough to process a ray.
variable 'z0' stands for where it located on z axis, curv denotes its curvature (equals 1/radius), n1 and n2 are refractive indexes.

To create an output plane, use
    plane = output_plane(z0)
, all rays will be terminated when hit on this plane.

To simulate a optical process, create a couple of optical element and contain them in a list 'elements' (e.g.,[surf1, surf2, surf3...])
and then run
    focus_z = find_focus(elements)
then put an output plane at [0,0,focus_z] ( use 'plane = output_plane(focus_z)'  )
and also add this plane to the optical elements group, by running:
    elements.append(plane)
And then we get the whole optical elements group. Actually two models have already written here, which can be generated by running
    elements = Simple_modelling()
or running
    elements = planoconvex_lens_modelling(direct). Here direct can be 'left' or 'right', which is by default 'left'. In these two models elements already include output plane.

To run a simulation, use
    raylist = simulating_random(elements,n) n is the number of rays generated randomly;
or
    raylist = simulating_symmetrical(elements,n,m) m is the diameter of the generated ray bundle and n means how many rays a single circle contains.
These two functions returns a processed raylist. To visualize it after a simulation, run
    x,y = visualize(raylist,color=None) here 'color' is by default None, and can be customized if assigned 'r','b','g',etc.
two plots will appear. The top one shows how rays propagate and the bottom one shows what displays on the output plane.
In addition, the points data are stored in two lists: x and y, so we can calculate the RMS deviation by running
    RMSD = RMS_calculation(x,y)

This program by itself will simulate the process when a bundle of rays pass planoconvex lens. Just run it by
    python raytracer.py
'''
def snell(n1,n2,dir,norm):
        '''
        This function returns the output unit vector after a refraction procedure.
        'dir' is the vector of incoming rays
        sin1 n1 = sin2 n2
        sin2 = sin1 n1/n2
        '''
        cos1=np.dot(-dir,norm)
        sin1=np.sqrt(1-cos1*cos1)
        sin2 = sin1 * n1/n2
        plane_norm = np.cross(norm,dir) # the normal vector of the plane determined by sphere's normal vector and incident ray
        if sin2>1:
            return np.array()
        dir_out = n1 / n2 * (np.cross(norm,-plane_norm))-norm * np.sqrt(1-sin2*sin2)
        return dir_out

class ray():
    '''
    Class describing a ray. If ray.terminated=True, then it stops propagating.
    '''
    def __init__(self,pos = [0,0,0],dir = [0,0,1]):
        self.pos = np.array([pos])
        self.dir = np.array([dir])
        self.terminated = False

    def p(self):
        return self.pos[-1]

    def k(self):
        return self.dir[-1]

    def append(self,p,k):
        if len(p)==1:
            self.pos=np.append(self.pos,p,axis=0)
            self.dir=np.append(self.dir,k,axis=0)
        elif len(p)==3:
            self.pos=np.append(self.pos,[p],axis=0)
            self.dir=np.append(self.dir,[k],axis=0)
        else:
            print 'Please check your input again!'

    def vertices(self):
        return self.pos

    def terminate(self):
        self.terminated = True

class optical_element():
    def propagate_ray(self,ray):
        "propagate a ray through the optical element"
        raise NotImplementedError()

class spherical_refraction(optical_element):
    '''
    z0: intercept of the surface with the z-axis;
    curvature:the curvature of the surface, a signed quantity with magnitude 1/radius of curvature
    while z(centre of curvature) > z0 and negative z<z0, zero if corresponds to a plane.
    n1,n2: refractive indices either side of the surface
    aperture radius: the maximum extent of the surface from the optical axis
    '''
    def __init__(self,z0,curv,n1,n2,ar=50):
        self.z0=z0
        self.curv=curv
        self.n1=n1
        self.n2=n2
        self.ar=ar

    def intercept(self,ray):
        '''
        return the distance between the intercept and ray point
        '''
        if not self.curv==0: #This is a sphere
            radius = 1/float(self.curv) #radius of the sphere
            centre = radius + self.z0 # centre of the sphere
            r = ray.p()-np.array([0,0,centre]) #vector from the centre of the sphere pointing to the ray point.
            rk = np.dot( r, ray.k() )
            if rk>0:
                return None
            temp = rk * rk - (np.dot(r,r)-radius*radius)
            if temp > 0: # should have two intercept
                l1 = -rk + np.sqrt(temp) #distance from intercept to ray point
                l2 = -rk - np.sqrt(temp)
                if self.curv>0:
                    l = min(l1,l2)
                elif self.curv<0:
                    l = max(l1,l2)
            elif temp == 0:
                l = -rk
            else:
                l = None
        else: #self.curv=0, which is a plane
            cos=np.dot(ray.k(),np.array([0,0,1]))
            l = (self.z0 - ray.p()[2]) / cos
        #Check within aperture or not:
        if l:
            pos_intercept = ray.p()+ray.k()*l
            x,y=pos_intercept[0],pos_intercept[1]
            if x*x+y*y > self.ar*self.ar: #not within
                l = None
        return l

    def propagate_ray(self,ray):
        l = self.intercept(ray)
        if not l==None:
            pos_intercept = ray.p()+ray.k()*l
            if self.curv==0: # This is a plane
                norm = np.array([0,0,-1])
            elif self.curv>0:
                radius = 1/float(self.curv)
                centre = radius + self.z0
                centre = np.array([0,0,centre])
                norm = pos_intercept-centre
                norm /= np.sqrt(np.dot(norm,norm)) #normalize
            else:#<0
                radius = 1/float(self.curv)
                centre = radius + self.z0
                centre = np.array([0,0,centre])
                norm = -pos_intercept + centre
                #print norm
                norm /= np.sqrt(np.dot(norm,norm)) #normalize
            dir_out = snell(self.n1,self.n2,ray.k(),norm)
            if not (dir_out == None):
                ray.append(pos_intercept,dir_out)
            else:
                ray.terminate()

class output_plane(optical_element):
    def __init__(self,z0):
        self.z0=z0
    def intercept(self,ray):
        cos=np.dot(ray.k(),np.array([0,0,1]))
        l = (self.z0 - ray.p()[2]) / cos
        return l
    def propagate_ray(self,ray):
        l=self.intercept(ray)
        pos_intercept=ray.p()+ray.k()*l
        ray.append(pos_intercept,[0,0,1])
        ray.terminate()

def find_focus(elements): # this function return the focus point of an optical elements group, in x-z plane
    '''
    Since the rays do not focus at one point accurately, we will average the point when x=0
    '''
    testray = ray([0.01,0,0],[0,0,1])
    for ele in elements:
        ele.propagate_ray( testray )

    k = testray.k()
    p = testray.p()
    if (k[0] > 0):
        print 'No real image can be generated!'
        return None
    l = - p[0] / k[0]
    focus_pos = p+k*l #should be a point [0,y,z]
    focus_z = focus_pos[2]
    return focus_z


def Simple_modelling():
    surf = spherical_refraction(100.,0.03,1.0,1.5,50)
    elements=[surf]
    focus_z=find_focus(elements)
    plane = output_plane(focus_z)
    elements.append(plane)

    return elements

def planoconvex_lens_modelling(direct='left'):#direct='left' means spherical surface->plane, and otherwise the spherical surface comes following the plane.
    if direct=='left':
        surf1 = spherical_refraction(100.0, 0.02, 1.0,    1.5168, 50)
        surf2 = spherical_refraction(105.0, 0,    1.5168, 1.0,    50)
    else:
        surf1 = spherical_refraction(100.0, 0,    1.0,    1.5168, 50)
        surf2 = spherical_refraction(105.0, -0.02,    1.5168, 1.0,    50)
    elements = [surf1,surf2]

    #find the paraxis focus
    focus_z=find_focus(elements)
    #put the output plane at focus_z
    plane = output_plane(focus_z)

    elements.append(plane)
    return elements



def simulating_random(elements,n=50):#This only works when elements contains an output plane.
    raylist=[]
    for i in range(n): # generate n rays
        pos_xy = 8*np.random.random(2)-4
        pos = np.append(pos_xy,[0])
        ry=ray(pos,[0,0,1])
        raylist.append(ry)
    for ry in raylist:
        for ele in elements:
            ele.propagate_ray(ry)
    return raylist

def simulating_symmetrical(elements,n=10,m=10):#n determines how many rays in one circle, m determines diameter
    raylist=[]
    for i in range(m):
        for j in range(n):
            pos=i/2.*np.array([np.cos(2*np.pi/n*j),np.sin(2*np.pi/n*j),0])
            raylist.append(ray(pos,[0,0,1]))
    for ry in raylist:
        for ele in elements:
            ele.propagate_ray(ry)
    return raylist


def visualize(rays,color=None):
    fig=plt.figure()
    fig1 = fig.add_subplot(3,1,1)
    fig2 = fig.add_subplot(3,1,2)
    fig3 = fig.add_subplot(3,1,3)
    for ray in rays:
        x=[]
        y=[]
        for pos in ray.pos:
            pos_x=pos[2]
            pos_y=pos[0]
            x.append(pos_x)
            y.append(pos_y)
        if color:
            fig1.plot(x,y,color)
        else:
            fig1.plot(x,y)
    x=[]
    y=[]
    for ray in rays:
        p=ray.pos[0]
        x.append(p[0])
        y.append(p[1])
    fig2.plot(x,y,'ro')
    x=[]
    y=[]
    for ray in rays:
        p=ray.p()
        x.append(p[0])
        y.append(p[1])
    fig3.plot(x,y,'ro')
    plt.show()
    return x,y

def RMS_calculation(x,y):
    s=0
    for i in range(len(x)):
        s += x[i]*x[i]+y[i]*y[i]
    s/=float(len(x))
    return np.sqrt(s)

if __name__=="__main__":
    elements = planoconvex_lens_modelling()
    raylist = simulating_symmetrical(elements,30)
    x,y = visualize(raylist)
    print 'RMS deviation for planoconvex lens is: %f'%RMS_calculation(x,y)
    '''
    elements = Simple_modelling()
    raylist = simulating_symmetrical(elements,30)
    x,y = visualize(raylist)
    print 'RMS deviation for planoconvex lens is: %f'%RMS_calculation(x,y)
    '''
